<p>Since version 0.9.5, the SUMO-package contains a routing module named <a href="/DFROUTER" title="wikilink">DFROUTER</a>. The idea behind this router is that nowadays, most highways are well equipped with induction loops, measuring each of the highways’ entering and leaving flows. Given this information one may assume that the flows on the highway are completely known. <a href="/DFROUTER" title="wikilink">DFROUTER</a> uses directly the information collected from induction loops to rebuild the vehicle amounts and routes. This is done in several steps, being mainly:</p>

<ol>
  <li>Computing (and optionally saving) the detector types in the means that each induction is set to be a source detector, a sink detector or an in-between detector</li>
  <li>Computing (and optionally saving) the routes between the detectors</li>
  <li>Computing the flow amounts between the detectors</li>
  <li>Saving the flow amounts and further control structures</li>
</ol>

<h2 id="computing-detector-types">Computing Detector Types</h2>

<p>The idea behind the <a href="/DFROUTER" title="wikilink">DFROUTER</a> assumes that a network is completely covered by detectors, meaning that all off- and on-ramps have an induction loop placed on them. Such an information whether an induction loop is a pure source or sink or whether it is placed between such is but not given initially. It must be computed. To do this, the <a href="/DFROUTER" title="wikilink">DFROUTER</a> needs the underlying network as well as a list of detector definitions where each describes the position of an induction loop. The network, being a previously built SUMO-network, is supplied to the <a href="/DFROUTER" title="wikilink">DFROUTER</a> as usual using the () option, the list of induction loops using ( for short). A detector file should look as follows:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;detectors&gt;
   &lt;detectorDefinition id="&lt;DETECTOR_ID&gt;" lane="&lt;LANE_ID&gt;" pos="&lt;POS&gt;"/&gt;
... further detectors ...
&lt;/detectors&gt;
</code></pre></div></div>

<p>This means that each detector is initially described using its id, a lane it is placed on, and a position on the lane. To be exact:</p>

<ul>
  <li>id: A string holding the id of the detector</li>
  <li>lane: The id of the lane the detector lies on. Must be a lane within the network.</li>
  <li>pos: The position on the lane the detector shall be laid on in meters. The position must be a value between -1*lane’s length and the lane’s length. In the case of a negative value, the position will be computed backward from the lane’s end (the position the vehicles drive towards).</li>
</ul>

<p>Given a network and the list of detectors, <a href="/DFROUTER" title="wikilink">DFROUTER</a> assigns types to detectors and saves the so extended list into a file if the option is given. This list looks like the input described above except that an aditional attribute is given for each detector, “type”, which may have one of the following values: “source”, “sink”, “between”, and “discarded”. You can also generate a list of points of interests (POIs) which can be read by <a href="/SUMO-GUI" title="wikilink">SUMO-GUI</a> where each POI represents a detector and is colored by the detector type: green for source detectors, red for sink detectors, blue for in-between detectors, and black for discarded detectors. To force <a href="/DFROUTER" title="wikilink">DFROUTER</a> to do this, use .</p>

<p>When wished, if for example other parameters chage, the extended <DETECTOR_OUTPUT_FILE> can be fed back again into [DFROUTER](/DFROUTER "wikilink") instead of the previous <DETECTOR_FILE>. In this case the detector types do not have to be computed again. To force [DFROUTER](/DFROUTER "wikilink") to recompute the types, use .</DETECTOR_FILE></DETECTOR_OUTPUT_FILE></p>

<h2 id="computing-routes">Computing Routes</h2>

<p>Now that we do know where vehicles enter and where they leave the network, we may compute routes for each of the pairs. The <a href="/DFROUTER" title="wikilink">DFROUTER</a> is told to build and save routes using where <ROUTE_OUTPUT_FILE> is the name of the file the computed routes shall be written to. The generated file only contains routes, no vehicle type definitions and no vehicles.</ROUTE_OUTPUT_FILE></p>

<p>Normally, only routes starting at source detectors and ending at sink detectors are computed. Using the option you can force <a href="/DFROUTER" title="wikilink">DFROUTER</a> to also build routes that start at in-between detectors. The option will make the routes not end at the edge the source detector is placed on, but on all edges that follow this edge. will also keep those routes where a sink detector could not be found for what may be the case if the network is not completely covered with induction loops.</p>

<h2 id="computing-flows">Computing Flows</h2>

<p>The next step is to use the computed routes and flow amounts from the real-world detectors to compute flows across the modelled network. The flows are given to DFROUTER using (or . They are assumed to be stored in CSV-format using ‘;’ as dividing character. The file should look as follows:</p>

<p><code class="highlighter-rouge">Detector;Time;qPKW;qLKW;vPKW;vLKW</code>
<code class="highlighter-rouge">myDet1;0;10;2;100;80</code>
<code class="highlighter-rouge">... further entries ...</code></p>

<p>This means the first time has to name the entries (columns). Their order is not of importance, but at least the following columns must be included:</p>

<ul>
  <li>Detector: A string holding the id of the detector this line describes; should be one of the ids used in <DETECTOR_FILE></DETECTOR_FILE></li>
  <li>Time: The time period begin that this entry describes (in minutes)</li>
  <li>qPKW: The number of passenger cars that drove over the detector within this time period</li>
  <li>vPKW: The average speed of passenger cars that drove over the detector within this time period in km/h</li>
</ul>

<p>The following columns may optionally be included:</p>

<ul>
  <li>qLKW: The number of transport vehicles that drove over the detector within this time period</li>
  <li>vLKW: The average speed of transport vehicles that drove over the detector within this time period in km/h</li>
</ul>

<p>These are not quite the values to be found in induction loop output. We had to constrain the <DETECTOR_FLOWS> files this way because DFROUTER is meant to read very many of such definitions and to do this as fast as possible.</DETECTOR_FLOWS></p>

<p>Because in some cases one reads detector flow definitions starting at a certain time but wants the simulation to begin at another, it is possible to add a time offset using which is the number of seconds to subtracted from the read times.</p>

<h3 id="algorithm-properties">Algorithm Properties</h3>

<p><a href="/DFROUTER" title="wikilink">DFROUTER</a> works best when all possible source and sink edges are supplied with detector values and these values are evenly spaced in time. The algorithm works under the assumption that the sum of source flows matches the sum of sink flows for every measurement interval (thus somewhat ignoring travel time). Some properties of <a href="/#Generating_Vehicles" title="wikilink">Vehicle generation</a>:</p>

<ul>
  <li>The number of generated vehicles for each measurement interval is determined by source detectors alone.
    <ul>
      <li>Excess flow at sink detectors is ignored</li>
      <li>If sink detectors measure less flow, it will nevertheless arrive there in proportion to the measured flow</li>
      <li>If sink detectors measure no flow at all, all vehicles will drive to one (arbitrary) sink</li>
    </ul>
  </li>
</ul>

<p>The number of will be determined by</p>

<h2 id="generating-vehicles">Generating Vehicles</h2>

<p>If flow definitions were supplied, we can let the DFROUTER save the computed vehicles together with their routes. Vehicles will be generated at the source detectors which are placed at certain positions of the networks’ lanes. DFROUTER generates vehicle with the option . This file will contain vehicle (emitter) declarations for each of the source detectors. If no value is given, vehicles will not be written. Accompanying, there will be each with the same name as a detector. These reflect the distribution of routes at the detector with the same ID.</p>

<p>By default vehicles are inserted with even spacing over each measurement interval. This can be changed by adding the option .</p>

<p>The generated file contains individual vehicles which are assigned routes from the <a href="/#Computing_Routes" title="wikilink">routes-output file</a>.</p>

<h2 id="further-outputs">Further Outputs</h2>

<h3 id="variable-speed-signs">Variable Speed Signs</h3>

<p>As some approaches use a speed limit to avoid open-end boundary problems, the DFROUTER can generate a list of speed triggers (see “Variable Speed Signs (VSS)”) placed on the positions of sink detectors. The name to save the declaration of these speed triggers into is given using the option . The according variable speed sign definitions will be written into files named “vss_<DETECTOR_ID>.def.xml” where <DETECTOR_ID> is the name of the according sink detector.</DETECTOR_ID></DETECTOR_ID></p>

<h3 id="rerouters">Rerouters</h3>

<p>In order not to end vehicle routes on off-ramps, it is possible to place rerouters (see “Rerouter”) at the positions of the sink detectors, too. Giving the option will generate a list of rerouter declarations. Please remark that in this case, no rerouter definitions are written, because the DFROUTER has no further information about possible routes beyond the area covered by the detectors.</p>

<h3 id="validation-detectors">Validation Detectors</h3>

<p>It’s quite nice to have the possibility to check whether the simulation does what one wants. To validate whether the same flows are found within the simulation as within the reality, the option may be helpful. It generates a list of detector definitions (see “<a href="/Simulation/Output/Induction_Loops_Detectors_(E1)" title="wikilink">inductive loop detectors</a>”) placed at the positions of sink and in-between detectors. Their output will be saved into files named “validation_det_<DETECTOR_ID>.xml” and should be easily comparable to the detector flows previously fed to the router. The option will let DFROUTER also build inductive loop detectors for source detectors which are place 1m behind the real-life detector's position.</DETECTOR_ID></p>

<h2 id="how-to-include-the-files">How to include the files</h2>

<p>The <a href="/DFROUTER" title="wikilink">DFROUTER</a> is unique among the <strong>SUMO</strong>-routing applications in that it outputs routes and vehicles separately. <a href="/SUMO#Loading_order_of_input_files" title="wikilink">You need to make sure that the list of input files is in the correct order for resolving references</a>. Furthermore, <a href="/DFROUTER" title="wikilink">DFROUTER</a> currently returns unsorted vehicles in its emitters-output. Assuming that <a href="/DFROUTER" title="wikilink">DFROUTER</a> was called with the options</p>

<p><code class="highlighter-rouge">dfrouter --net-file net.net.xml --routes-output routes.rou.xml --emitters-output vehicles.xml ...</code></p>

<p>SUMO must be called in the following way:</p>

<p><code class="highlighter-rouge"> sumo --net-file net.net.xml --additional-files routes.rou.xml,emitters.rou.xml</code></p>

<p>If you run the tool <a href="/Tools/Routes#sort_routes.py" title="wikilink">Tools/Routes#sort_routes.py</a> to sort the emitters, either of the following will work:</p>

<p><code class="highlighter-rouge"> sumo --net-file net.net.xml --route-files routes.rou.xml,sorted_emitters.rou.xml</code>
<code class="highlighter-rouge"> sumo --net-file net.net.xml --route-files sorted_emitters.rou.xml --additional-files routes.rou.xml</code></p>
